### stage4

#### 目标

实现class的生命周期。

因为我们着急要实现更新功能，所以我们这个阶段，先考虑只实现componentDidMount函数。

#### 思路

- 为什么要引入生命周期？
  首先我们来思考，为什么要引入生命周期。react带给我们的一大便捷就是我们可以使用组件的方式来拆分和组织我们的代码。但是我们该如何编写和管理我们的组件呢。按照我们前端页面的逻辑，我们进到页面后，要等待装载，装载完成后执行我们的初始化代码，包括绑定事件，发送请求获取数据等。这些做完后，我们就等待用户事件的触发，然后做出相应的响应，更新我们的页面。最后离开页面时，我们做一些清理工作。
  所以，抽象总结我们页面的行为，就是装载、更新、下载，三大类流程。react也是对这三类流程进行细分，然后给出了生命周期的概念，让我们可以在相应的阶段，进行介入，执行我们的代码。其实，把我们之前写的操作DOM式的代码整理整理，大体上也就是这几个时间点。所以这么划分和抽象是完全合理的。

- 引入什么样的声明周期
  接下来我们就要考虑，在对三大类流程细分的时候，究竟要划分哪些小的声明周期。我们先抛开react，自己来思考要引入什么样的生命周期。
  首先来看装载阶段。想要装载一个组件，我们肯定要先创建一个组件。所以，我们可以分为：预创建、创建、创建后预装载、装载、装载后。预创建阶段，我们根本没有机会执行我们的代码，所以去掉。创建阶段，就是执行我们组件类的constructor的时候。创建后预装载阶段，这段时间，我们我们得到了我们组件的实例，我们可以调用组件类上的方法和属性。我们暂时想不到要做什么，所以我们就先认为这个阶段什么都不做。然后就到了装载阶段，这个阶段，我们根据jsx提取出的信息，创建dom元素，然后添加到页面中去，这样，装载阶段就完成了。然后就到了装载后阶段，装载后阶段，我们就要执行事件绑定、服务器数据获取等等事情了。
  我们再来看更新阶段。我们想象一下更新一个事物时的流程，我们一般是接收到了新的属性或者新的值，然后我们认为有必要响应这个改变，就根据这个值更新我们的事物，然后再体现到页面上。所以我们更新的阶段大致上可以划分为：接收到新的属性或者值、判断是否响应这个改变、更新自身、更新后。前面两个阶段很好理解，我们不多说，我们来看下更新自身和更新后这两个阶段。按照我们stage2的想法，我们更新一个组件，只需要根据新的属性重新执行一遍render，然后添加到页面上即可。这种方式在页面结构小的时候或者整个页面时常发生巨大变化的时候可行，但是通常我们碰到的页面体量都不小，然后每次变动的时候都是局部的变化。所以我们就不能采用这种方式。我们需要一种方式能够感知到页面中哪些部分发生了变化，然后再执行局部的更新。所以，react引入了virtual DOM和Fiber的概念，就是来完成这个功能的。所以，回过头来看，装载阶段，创建后预装载前，我们应该创建virtual DOM或者Fiber。
  最后来看卸载阶段。卸载阶段就很简单了，分为预卸载、卸载就好了。预卸载阶段我们执行一些clean up工作，卸载阶段就是把组件从页面中去除了。

- 怎样引入生命周期
  怎样引入其实就很简单了，生命周期其实就是一个个钩子，我们在相应的声明周期，去调用相应的钩子就好。

- 我们来考虑如何实现componentDidMount，CDM的运行时机应该是在commit之后，所以，我们要考虑两件事
  - 如何保存我们的CDM函数
  - 如何保存上下文
如果，我们用一个栈来存储这些实例对象，然后commit之后，再挨个取出来执行。    

#### 实施
我们先只考虑装载阶段，这部分的难点很显然，就是如何构建virtual DOM或者Fiber了。我们这里考虑实现的是Fiber。    

#### 总结

这一阶段没有什么难点，主要是对reactElement一些属性的解析。