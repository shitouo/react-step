### stage4

#### 目标

实现class的生命周期。

因为我们着急要实现更新功能，所以我们这个阶段，先考虑只实现componentDidMount函数。

#### 思路

- 为什么要引入生命周期？
  首先我们来思考，为什么要引入生命周期。react带给我们的一大便捷就是我们可以使用组件的方式来拆分和组织我们的代码。但是我们该如何编写和管理我们的组件呢。按照我们前端页面的逻辑，我们进到页面后，要等待装载，装载完成后执行我们的初始化代码，包括绑定事件，发送请求获取数据等。这些做完后，我们就等待用户事件的触发，然后做出相应的响应，更新我们的页面。最后离开页面时，我们做一些清理工作。
  所以，抽象总结我们页面的行为，就是装载、更新、卸载，三大类流程。react也是对这三类流程进行细分，然后给出了生命周期的概念，让我们可以在相应的阶段，进行介入，执行我们的代码。其实，把我们之前写的操作DOM式的代码整理整理，大体上也就是这几个时间点。所以这么划分和抽象是完全合理的。

- 引入什么样的声明周期
  接下来我们就要考虑，在对三大类流程细分的时候，究竟要划分哪些小的声明周期。我们先抛开react，自己来思考要引入什么样的生命周期。
  首先来看装载阶段。想要装载一个组件，我们肯定要先创建一个组件。所以，我们可以分为：预创建、创建、创建后预装载、装载、装载后。预创建阶段，我们根本没有机会执行我们的代码，所以去掉。创建阶段，就是执行我们组件类的constructor的时候。创建后预装载阶段，这段时间，我们我们得到了我们组件的实例，我们可以调用组件类上的方法和属性。我们暂时想不到要做什么，所以我们就先认为这个阶段什么都不做。然后就到了装载阶段，这个阶段，我们根据jsx提取出的信息，创建dom元素，然后添加到页面中去，这样，装载阶段就完成了。然后就到了装载后阶段，装载后阶段，我们就要执行事件绑定、服务器数据获取等等事情了。
  我们再来看更新阶段。我们想象一下更新一个事物时的流程，我们一般是接收到了新的属性或者新的值，然后我们认为有必要响应这个改变，就根据这个值更新我们的事物，然后再体现到页面上。所以我们更新的阶段大致上可以划分为：接收到新的属性或者值、判断是否响应这个改变、更新自身、更新后。前面两个阶段很好理解，我们不多说，我们来看下更新自身和更新后这两个阶段。按照我们stage2的想法，我们更新一个组件，只需要根据新的属性重新执行一遍render，然后添加到页面上即可。这种方式在页面结构小的时候或者整个页面时常发生巨大变化的时候可行，但是通常我们碰到的页面体量都不小，然后每次变动的时候都是局部的变化。所以我们就不能采用这种方式。我们需要一种方式能够感知到页面中哪些部分发生了变化，然后再执行局部的更新。所以，react引入了virtual DOM和Fiber的概念，就是来完成这个功能的。所以，回过头来看，装载阶段，创建后预装载前，我们应该创建virtual DOM或者Fiber。
  最后来看卸载阶段。卸载阶段就很简单了，分为预卸载、卸载就好了。预卸载阶段我们执行一些clean up工作，卸载阶段就是把组件从页面中去除了。

- 怎样引入生命周期
  怎样引入其实就很简单了，生命周期其实就是一个个钩子，我们在相应的声明周期，去调用相应的钩子就好。

- CMD的执行顺序和执行时机

#### 实施
我们先只考虑装载阶段，这部分的难点很显然，就是如何构建virtual DOM或者Fiber了。我们这里考虑实现的是Fiber。    

#### 总结

这一阶段没有什么难点，主要是对reactElement一些属性的解析。

#### 2020.6.17

react**规定**了几个生命周期，然后会在特定时间，**调用**我们编写的生命周期函数。这是在react框架下，实现可扩展的方式
而webpack则采用了发布订阅模式。同样是**规定**了几个生命周期，然后在特定时间，发布事件。

#### 2020.6.18

现在的版本，生成Fiber tree时，是递归进行的。中间是不能被打断的，这种实现方式违背了React设计Fiber的初衷，所以，这里要进行改版，将递归改成循环，引入workInProgress。

思维误区：以前对于workInProgress的理解好像有点不到位。workInProgress的构建一定是根据currentFiber节点构建出来，意思就是说，一定是根据current 这个Fiber Tree中的某个节点构建出来的。可能之前就构建过，这个时候。只需要更新workInProgress的pendingProps等动态属性就行。

pendingProps是个对象哦

memorizedState的值是个对象，其中可能的属性有
  - element： 

react的diff是有层次的。
  - 先是在reconcileChildren的时候，看children的type和key是否发生了变化，如果发生了变化，则直接标记已删除child

新增的节点也都会update的，即便是里面的子节点，都会进行update的。但是有一点很重要：**这些新增的节点，是不用track side effect的**。所以是没有Placement effect的。

**如果current是null的话，则其child没有必要标识Placement了，因为current是null的话，说明当前节点在页面上还没有渲染过，只给当前节点标识Placement就好。如果连其child都要标识的话，那就可能会标识很多Placement了。会影响最后的commit性能。未标识Placement的child，在回溯到其父节点时，会先createElement，然后把这些child都appendAllChildren。**