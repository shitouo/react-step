### stage5

#### 目标

这个阶段的目标是要实现fiber 的可打断和可恢复机制。

#### 思路

##### 什么时候开启异步

首先我们考虑什么时候开启异步渲染，对于用户的交互，如果交互后，立马就要修改状态的，说明变化是需要快速的映射到页面的，不然用户就会觉得卡了，所以这样的交互式不能被打断的。
对于交互后，要经过一些异步步骤后，才需要将变化映射到页面的，用户肯定是有一定预期的，所以即便页面没有立马发生变化，用户也是理解的，不会认为发生了卡顿。所以对于setTimeout或者promise等异步，我们要加入打断。

##### 怎样实现异步渲染

1. 我们会将reconcile阶段的工作放到每一帧的idle空闲时间去做，用的api就是window.requestIdleCallbak，但是这个api有兼容问题，所以我们先要用window.requestAnimation模拟一个requestIdleCallback出来

2. 因为会被打断，所以有一种情况很可能会发生，就是，当前异步的reconcile还没有完全结束，用户就发生了其他的交互，而且是那种不能被打断的交互，我们就得优先去处理那个任务，不然用户就会觉得卡顿了。所以对那些callback，我们需要引入优先级的概念，以方便能够优先处理那些优先级高的任务。

3. 考虑优先级的实现方式，如果我们只是单纯地设定几个优先级，那对于同级别的事件，我们还需要考虑事件发生的早晚，也就是要考虑时间。所以我们改为用时间来代表优先级，以当前时间为基础，再加上几个优先级级别代表的固定时间。

4. 但是这样造成的后果就是，优先级值越小代表的优先级越大，有点不太符合常识，所以改为预先设定一个很大的值，然后用这个值减去当前优先级值，作为我们最后要用的优先级值。

5. 而且使用时间代表优先级后，就不会出现低优先级的任务被饿死的情况。因为时间是在往前走的，发生在很靠后的同步任务可能优先级会比很早之前发生的异步任务优先级低（这里存疑，同步任务会进到unstable_scheduleCallback中进行调度吗？）

#### 实施

1. 识别setState的调用场合，是直接同步调用，还是在异步环境中调用的 --- 用isBatchingUpdates来区分
2. 对于同步调用的，直接走初始化时的路径，不考虑打断
3. 对于异步调用的，实现callback的调度机制。
4. 实现被打断后的恢复机制 和 更高优先级插入的执行机制

#### 总结
